<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>🔧 統合デバッグツール - 障害年金管理システム</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .log-entry {
            margin: 4px 0;
            padding: 8px 12px;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.5;
            word-break: break-all;
        }
        .log-success { background-color: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .log-error { background-color: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
        .log-info { background-color: #d1ecf1; color: #0c5460; border: 1px solid #bee5eb; }
        .log-warning { background-color: #fff3cd; color: #856404; border: 1px solid #ffeeba; }
        .log-debug { background-color: #e2e3e5; color: #383d41; border: 1px solid #d6d8db; }
        
        .json-viewer {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 12px;
            margin-top: 8px;
            max-height: 400px;
            overflow-y: auto;
        }
        
        pre {
            margin: 0;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        
        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 8px;
            animation: pulse 2s infinite;
        }
        
        .status-connected { background-color: #28a745; }
        .status-disconnected { background-color: #dc3545; }
        .status-checking { background-color: #ffc107; }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        .tab-button {
            transition: all 0.2s ease;
        }
        
        .tab-button.active {
            background-color: #3b82f6;
            color: white;
            border-bottom: 2px solid #1d4ed8;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen p-4">
    <div class="max-w-7xl mx-auto">
        <div class="bg-white rounded-lg shadow-lg p-6 mb-6">
            <h1 class="text-3xl font-bold text-gray-800 mb-2">🔧 統合デバッグツール</h1>
            <p class="text-gray-600">API接続、データベース、そしてproject-unified.htmlの問題を包括的に診断します</p>
        </div>

        <!-- 強化された接続状態ダッシュボード -->
        <div class="bg-white rounded-lg shadow p-6 mb-6">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-semibold flex items-center">
                    <span id="connectionStatus" class="status-indicator status-checking"></span>
                    接続状態監視
                </h2>
                <div class="flex space-x-2">
                    <button onclick="toggleConnectionMonitor()" id="monitorToggle"
                            class="bg-blue-500 hover:bg-blue-600 text-white font-medium py-1 px-3 rounded text-sm transition-colors">
                        監視開始
                    </button>
                    <button onclick="runConnectionDiagnostics()"
                            class="bg-green-500 hover:bg-green-600 text-white font-medium py-1 px-3 rounded text-sm transition-colors">
                        詳細診断
                    </button>
                    <button onclick="runSpeedTest()"
                            class="bg-purple-500 hover:bg-purple-600 text-white font-medium py-1 px-3 rounded text-sm transition-colors">
                        速度テスト
                    </button>
                </div>
            </div>
            
            <!-- 接続品質メトリクス -->
            <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-4">
                <div class="bg-gray-50 p-3 rounded text-center">
                    <h4 class="text-xs font-medium text-gray-600 mb-1">レイテンシ</h4>
                    <p id="latencyMetric" class="text-lg font-bold text-blue-600">-</p>
                    <p class="text-xs text-gray-500">ms</p>
                </div>
                <div class="bg-gray-50 p-3 rounded text-center">
                    <h4 class="text-xs font-medium text-gray-600 mb-1">安定性</h4>
                    <p id="stabilityMetric" class="text-lg font-bold text-green-600">-</p>
                    <p class="text-xs text-gray-500">%</p>
                </div>
                <div class="bg-gray-50 p-3 rounded text-center">
                    <h4 class="text-xs font-medium text-gray-600 mb-1">成功率</h4>
                    <p id="successRateMetric" class="text-lg font-bold text-purple-600">-</p>
                    <p class="text-xs text-gray-500">%</p>
                </div>
                <div class="bg-gray-50 p-3 rounded text-center">
                    <h4 class="text-xs font-medium text-gray-600 mb-1">品質</h4>
                    <p id="qualityMetric" class="text-lg font-bold text-orange-600">-</p>
                    <p class="text-xs text-gray-500">評価</p>
                </div>
            </div>
            
            <!-- エンドポイント別状態 -->
            <div class="grid grid-cols-1 md:grid-cols-4 gap-4">
                <div class="bg-gray-50 p-4 rounded">
                    <h3 class="font-medium text-gray-700 mb-2 flex items-center">
                        <span id="apiStatusIndicator" class="status-indicator status-checking mr-2"></span>
                        APIサーバー
                    </h3>
                    <p id="apiStatus" class="text-sm text-gray-600">確認中...</p>
                    <p id="apiResponseTime" class="text-xs text-gray-500 mt-1">-</p>
                </div>
                <div class="bg-gray-50 p-4 rounded">
                    <h3 class="font-medium text-gray-700 mb-2 flex items-center">
                        <span id="dbStatusIndicator" class="status-indicator status-checking mr-2"></span>
                        データベース
                    </h3>
                    <p id="dbStatus" class="text-sm text-gray-600">確認中...</p>
                    <p id="dbResponseTime" class="text-xs text-gray-500 mt-1">-</p>
                </div>
                <div class="bg-gray-50 p-4 rounded">
                    <h3 class="font-medium text-gray-700 mb-2 flex items-center">
                        <span id="authStatusIndicator" class="status-indicator status-checking mr-2"></span>
                        認証状態
                    </h3>
                    <p id="authStatus" class="text-sm text-gray-600">確認中...</p>
                    <p id="authResponseTime" class="text-xs text-gray-500 mt-1">-</p>
                </div>
                <div class="bg-gray-50 p-4 rounded">
                    <h3 class="font-medium text-gray-700 mb-2 flex items-center">
                        <span id="unifiedStatusIndicator" class="status-indicator status-checking mr-2"></span>
                        project-unified
                    </h3>
                    <p id="unifiedStatus" class="text-sm text-gray-600">確認中...</p>
                    <p id="unifiedResponseTime" class="text-xs text-gray-500 mt-1">-</p>
                </div>
            </div>
        </div>

        <!-- タブナビゲーション -->
        <div class="bg-white rounded-lg shadow mb-6">
            <div class="border-b border-gray-200">
                <nav class="-mb-px flex space-x-8 px-6">
                    <button onclick="switchTab('api-test')" class="tab-button py-4 px-1 border-b-2 border-transparent font-medium text-sm text-gray-500 hover:text-gray-700 hover:border-gray-300 active">
                        🚀 API テスト
                    </button>
                    <button onclick="switchTab('project-debug')" class="tab-button py-4 px-1 border-b-2 border-transparent font-medium text-sm text-gray-500 hover:text-gray-700 hover:border-gray-300">
                        🐛 project-unified 診断
                    </button>
                    <button onclick="switchTab('console-monitor')" class="tab-button py-4 px-1 border-b-2 border-transparent font-medium text-sm text-gray-500 hover:text-gray-700 hover:border-gray-300">
                        📊 コンソール監視
                    </button>
                    <button onclick="switchTab('network-monitor')" class="tab-button py-4 px-1 border-b-2 border-transparent font-medium text-sm text-gray-500 hover:text-gray-700 hover:border-gray-300">
                        🌐 ネットワーク監視
                    </button>
                    <button onclick="switchTab('auto-diagnosis')" class="tab-button py-4 px-1 border-b-2 border-transparent font-medium text-sm text-gray-500 hover:text-gray-700 hover:border-gray-300">
                        🤖 自動診断
                    </button>
                    <button onclick="switchTab('performance-monitor')" class="tab-button py-4 px-1 border-b-2 border-transparent font-medium text-sm text-gray-500 hover:text-gray-700 hover:border-gray-300">
                        ⚡ パフォーマンス
                    </button>
                    <button onclick="switchTab('connection-monitor')" class="tab-button py-4 px-1 border-b-2 border-transparent font-medium text-sm text-gray-500 hover:text-gray-700 hover:border-gray-300">
                        🔗 接続監視
                    </button>
                </nav>
            </div>
        </div>
        
        <!-- タブコンテンツ: API テスト -->
        <div id="api-test" class="tab-content active">
            <!-- API設定 -->
            <div class="bg-white rounded-lg shadow p-6 mb-6">
                <h2 class="text-xl font-semibold mb-4">🔧 API設定</h2>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-2">ベースURL</label>
                        <input type="text" id="baseUrl" value="https://nennkinn-claud.vercel.app/api" 
                               class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500">
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-2">認証トークン</label>
                        <input type="text" id="authToken" placeholder="Bearer token（オプション）"
                               class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500">
                    </div>
                </div>
            </div>

            <!-- クイックテスト -->
            <div class="bg-white rounded-lg shadow p-6 mb-6">
                <h2 class="text-xl font-semibold mb-4">⚡ クイックテスト</h2>
                <div class="grid grid-cols-1 md:grid-cols-4 gap-4">
                    <button onclick="testHealthCheck()" 
                            class="bg-green-500 hover:bg-green-600 text-white font-medium py-2 px-4 rounded transition-colors">
                        ヘルスチェック
                    </button>
                    <button onclick="testLogin()" 
                            class="bg-blue-500 hover:bg-blue-600 text-white font-medium py-2 px-4 rounded transition-colors">
                        ログインテスト
                    </button>
                    <button onclick="testApplications()" 
                            class="bg-purple-500 hover:bg-purple-600 text-white font-medium py-2 px-4 rounded transition-colors">
                        申請データ取得
                    </button>
                    <button onclick="testDatabaseConnection()" 
                            class="bg-indigo-500 hover:bg-indigo-600 text-white font-medium py-2 px-4 rounded transition-colors">
                        DB接続テスト
                    </button>
                </div>
            </div>

            <!-- カスタムリクエスト -->
            <div class="bg-white rounded-lg shadow p-6 mb-6">
                <h2 class="text-xl font-semibold mb-4">🛠️ カスタムリクエスト</h2>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-2">メソッド</label>
                        <select id="method" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500">
                            <option value="GET">GET</option>
                            <option value="POST">POST</option>
                            <option value="PUT">PUT</option>
                            <option value="DELETE">DELETE</option>
                        </select>
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-2">エンドポイント</label>
                        <input type="text" id="endpoint" placeholder="/applications" 
                               class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500">
                    </div>
                </div>
                <div class="mb-4">
                    <label class="block text-sm font-medium text-gray-700 mb-2">リクエストボディ（JSON）</label>
                    <textarea id="requestBody" rows="4" placeholder='{"key": "value"}'
                              class="w-full px-3 py-2 border border-gray-300 rounded-md font-mono text-sm focus:outline-none focus:ring-2 focus:ring-blue-500"></textarea>
                </div>
                <button onclick="sendCustomRequest()" 
                        class="bg-gray-600 hover:bg-gray-700 text-white font-medium py-2 px-4 rounded transition-colors">
                    リクエスト送信
                </button>
            </div>
        </div>

        <!-- タブコンテンツ: project-unified 診断 -->
        <div id="project-debug" class="tab-content">
            <div class="bg-white rounded-lg shadow p-6 mb-6">
                <h2 class="text-xl font-semibold mb-4">🐛 project-unified.html 診断</h2>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                    <button onclick="testUnifiedPageLoad()" 
                            class="bg-orange-500 hover:bg-orange-600 text-white font-medium py-2 px-4 rounded transition-colors">
                        ページ読み込みテスト
                    </button>
                    <button onclick="testApplicationApiLoad()" 
                            class="bg-teal-500 hover:bg-teal-600 text-white font-medium py-2 px-4 rounded transition-colors">
                        application-api.js チェック
                    </button>
                    <button onclick="simulateEditMode()" 
                            class="bg-pink-500 hover:bg-pink-600 text-white font-medium py-2 px-4 rounded transition-colors">
                        編集モード(?edit=1) 模擬
                    </button>
                    <button onclick="testLocalStorageData()" 
                            class="bg-cyan-500 hover:bg-cyan-600 text-white font-medium py-2 px-4 rounded transition-colors">
                        ローカルストレージ確認
                    </button>
                </div>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                    <button onclick="testProjectUnifiedDirectly()" 
                            class="bg-violet-500 hover:bg-violet-600 text-white font-medium py-2 px-4 rounded transition-colors">
                        project-unified直接テスト
                    </button>
                    <button onclick="simulateFormSubmission()" 
                            class="bg-emerald-500 hover:bg-emerald-600 text-white font-medium py-2 px-4 rounded transition-colors">
                        フォーム送信模擬
                    </button>
                    <button onclick="testDOMManipulation()" 
                            class="bg-amber-500 hover:bg-amber-600 text-white font-medium py-2 px-4 rounded transition-colors">
                        DOM操作テスト
                    </button>
                    <button onclick="validateProjectUnifiedIntegrity()" 
                            class="bg-rose-500 hover:bg-rose-600 text-white font-medium py-2 px-4 rounded transition-colors">
                        整合性検証
                    </button>
                </div>
                <div class="mb-4">
                    <label class="block text-sm font-medium text-gray-700 mb-2">テスト用申請ID</label>
                    <input type="text" id="testApplicationId" value="1" placeholder="1" 
                           class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
            </div>
        </div>

        <!-- タブコンテンツ: コンソール監視 -->
        <div id="console-monitor" class="tab-content">
            <div class="bg-white rounded-lg shadow p-6 mb-6">
                <h2 class="text-xl font-semibold mb-4">📊 リアルタイムコンソール監視</h2>
                <div class="mb-4">
                    <button onclick="toggleConsoleCapture()" id="consoleToggle"
                            class="bg-green-500 hover:bg-green-600 text-white font-medium py-2 px-4 rounded transition-colors mr-2">
                        コンソール監視開始
                    </button>
                    <button onclick="clearConsoleLog()" 
                            class="bg-red-500 hover:bg-red-600 text-white font-medium py-2 px-4 rounded transition-colors">
                        コンソールクリア
                    </button>
                </div>
                <div id="consoleOutput" class="bg-gray-900 text-green-400 p-4 rounded-md font-mono text-sm max-h-96 overflow-y-auto">
                    コンソール監視待機中...
                </div>
            </div>
        </div>

        <!-- タブコンテンツ: ネットワーク監視 -->
        <div id="network-monitor" class="tab-content">
            <div class="bg-white rounded-lg shadow p-6 mb-6">
                <h2 class="text-xl font-semibold mb-4">🌐 ネットワークリクエスト監視</h2>
                <div class="mb-4">
                    <button onclick="toggleNetworkCapture()" id="networkToggle"
                            class="bg-blue-500 hover:bg-blue-600 text-white font-medium py-2 px-4 rounded transition-colors mr-2">
                        ネットワーク監視開始
                    </button>
                    <button onclick="clearNetworkLog()" 
                            class="bg-red-500 hover:bg-red-600 text-white font-medium py-2 px-4 rounded transition-colors">
                        ログクリア
                    </button>
                </div>
                <div id="networkOutput" class="bg-gray-50 p-4 rounded-md max-h-96 overflow-y-auto">
                    <div class="text-gray-500 text-sm">ネットワーク監視待機中...</div>
                </div>
            </div>
        </div>

        <!-- タブコンテンツ: 自動診断 -->
        <div id="auto-diagnosis" class="tab-content">
            <div class="bg-white rounded-lg shadow p-6 mb-6">
                <h2 class="text-xl font-semibold mb-4">🤖 自動診断シーケンス</h2>
                <div class="mb-4">
                    <p class="text-gray-600 mb-4">project-unified.htmlの問題を体系的に診断します。</p>
                    <button onclick="runFullDiagnosis()" id="diagnosisButton"
                            class="bg-gradient-to-r from-blue-500 to-purple-600 hover:from-blue-600 hover:to-purple-700 text-white font-medium py-3 px-6 rounded-lg transition-all mr-4">
                        🚀 完全診断開始
                    </button>
                    <button onclick="runQuickDiagnosis()" 
                            class="bg-green-500 hover:bg-green-600 text-white font-medium py-3 px-6 rounded-lg transition-colors">
                        ⚡ クイック診断
                    </button>
                </div>
                <div class="bg-gray-50 p-4 rounded-md">
                    <h3 class="font-medium text-gray-700 mb-2">診断進捗</h3>
                    <div class="w-full bg-gray-200 rounded-full h-2 mb-2">
                        <div id="diagnosisProgress" class="bg-blue-600 h-2 rounded-full transition-all duration-300" style="width: 0%"></div>
                    </div>
                    <div id="diagnosisStatus" class="text-sm text-gray-600">診断待機中...</div>
                </div>
                <div id="diagnosisResults" class="mt-4 space-y-2"></div>
            </div>
        </div>

        <!-- タブコンテンツ: パフォーマンス監視 -->
        <div id="performance-monitor" class="tab-content">
            <div class="bg-white rounded-lg shadow p-6 mb-6">
                <h2 class="text-xl font-semibold mb-4">⚡ パフォーマンス監視</h2>
                <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
                    <button onclick="measurePageLoadTime()" 
                            class="bg-blue-500 hover:bg-blue-600 text-white font-medium py-2 px-4 rounded transition-colors">
                        ページ読み込み速度
                    </button>
                    <button onclick="measureAPIResponseTime()" 
                            class="bg-green-500 hover:bg-green-600 text-white font-medium py-2 px-4 rounded transition-colors">
                        API応答時間
                    </button>
                    <button onclick="analyzeMemoryUsage()" 
                            class="bg-orange-500 hover:bg-orange-600 text-white font-medium py-2 px-4 rounded transition-colors">
                        メモリ使用量
                    </button>
                </div>
                <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
                    <div class="bg-gray-50 p-4 rounded">
                        <h3 class="font-medium text-gray-700 mb-2">読み込み時間</h3>
                        <p id="loadTimeMetric" class="text-2xl font-bold text-blue-600">-</p>
                        <p class="text-sm text-gray-500">ミリ秒</p>
                    </div>
                    <div class="bg-gray-50 p-4 rounded">
                        <h3 class="font-medium text-gray-700 mb-2">API平均応答</h3>
                        <p id="apiResponseMetric" class="text-2xl font-bold text-green-600">-</p>
                        <p class="text-sm text-gray-500">ミリ秒</p>
                    </div>
                    <div class="bg-gray-50 p-4 rounded">
                        <h3 class="font-medium text-gray-700 mb-2">メモリ使用量</h3>
                        <p id="memoryUsageMetric" class="text-2xl font-bold text-orange-600">-</p>
                        <p class="text-sm text-gray-500">MB</p>
                    </div>
                </div>
                <div class="bg-gray-50 p-4 rounded-md">
                    <h3 class="font-medium text-gray-700 mb-2">パフォーマンスログ</h3>
                    <div id="performanceLog" class="max-h-48 overflow-y-auto text-sm text-gray-600">
                        パフォーマンス測定待機中...
                    </div>
                </div>
            </div>
        </div>

        <!-- タブコンテンツ: 接続監視 -->
        <div id="connection-monitor" class="tab-content">
            <div class="bg-white rounded-lg shadow p-6 mb-6">
                <h2 class="text-xl font-semibold mb-4">🔗 高度な接続監視・診断</h2>
                
                <!-- 監視制御 -->
                <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
                    <button onclick="startContinuousMonitoring()" id="continuousMonitorBtn"
                            class="bg-blue-500 hover:bg-blue-600 text-white font-medium py-3 px-4 rounded transition-colors">
                        📡 連続監視開始
                    </button>
                    <button onclick="runFailoverTest()" 
                            class="bg-orange-500 hover:bg-orange-600 text-white font-medium py-3 px-4 rounded transition-colors">
                        🔄 障害復旧テスト
                    </button>
                    <button onclick="runLoadTest()" 
                            class="bg-red-500 hover:bg-red-600 text-white font-medium py-3 px-4 rounded transition-colors">
                        🚀 負荷テスト
                    </button>
                </div>
                
                <!-- 接続履歴グラフ -->
                <div class="mb-6">
                    <h3 class="font-medium text-gray-700 mb-3">接続履歴 (直近100回)</h3>
                    <div class="bg-gray-50 p-4 rounded-md">
                        <div id="connectionChart" class="flex items-end space-x-1 h-32 overflow-hidden">
                            <div class="text-gray-500 text-sm w-full text-center py-12">監視データ待機中...</div>
                        </div>
                    </div>
                </div>
                
                <!-- エンドポイント詳細状態 -->
                <div class="mb-6">
                    <h3 class="font-medium text-gray-700 mb-3">エンドポイント詳細状態</h3>
                    <div id="endpointDetails" class="space-y-3">
                        <!-- 動的に生成される -->
                    </div>
                </div>
                
                <!-- 接続問題レポート -->
                <div class="mb-6">
                    <h3 class="font-medium text-gray-700 mb-3">接続問題レポート</h3>
                    <div id="connectionIssues" class="bg-gray-50 p-4 rounded-md">
                        <div class="text-gray-500 text-sm">問題検出待機中...</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ログ表示 -->
        <div class="bg-white rounded-lg shadow p-6">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-semibold">📋 統合ログ</h2>
                <div class="space-x-2">
                    <button onclick="exportLogs()" 
                            class="bg-gray-500 hover:bg-gray-600 text-white font-medium py-1 px-3 rounded text-sm transition-colors">
                        エクスポート
                    </button>
                    <button onclick="clearLogs()" 
                            class="bg-red-500 hover:bg-red-600 text-white font-medium py-1 px-3 rounded text-sm transition-colors">
                        クリア
                    </button>
                </div>
            </div>
            <div id="logContainer" class="bg-gray-50 p-4 rounded-md max-h-96 overflow-y-auto">
                <div class="log-entry log-info">統合デバッグツールが準備完了しました</div>
            </div>
        </div>
    </div>

    <script>
        // グローバル変数
        let logs = [];
        let consoleCapturing = false;
        let networkCapturing = false;
        let originalConsole = {};
        let originalFetch = null;
        
        // 接続系強化変数
        let connectionMonitor = {
            isActive: false,
            interval: null,
            history: [],
            lastCheck: null,
            failureCount: 0,
            successCount: 0,
            averageResponseTime: 0,
            endpoints: [
                { name: 'Health Check', url: '/health', method: 'GET', critical: true },
                { name: 'Applications API', url: '/applications?limit=1', method: 'GET', critical: true },
                { name: 'Auth API', url: '/auth/login', method: 'POST', critical: false },
                { name: 'Static Files', url: '/js/application-api.js', method: 'GET', critical: true }
            ],
            retryConfig: {
                maxRetries: 3,
                retryDelay: 1000,
                backoffMultiplier: 2
            }
        };
        
        let networkQuality = {
            latency: 0,
            jitter: 0,
            packetLoss: 0,
            bandwidth: 0,
            stability: 'unknown'
        };

        // ログ出力関数
        function log(message, type = 'info', data = null) {
            const timestamp = new Date().toLocaleTimeString('ja-JP');
            const logEntry = {
                timestamp,
                message,
                type,
                data
            };
            logs.push(logEntry);
            
            const container = document.getElementById('logContainer');
            const entry = document.createElement('div');
            entry.className = `log-entry log-${type}`;
            
            let content = `[${timestamp}] ${message}`;
            entry.textContent = content;
            
            if (data) {
                const dataView = document.createElement('div');
                dataView.className = 'json-viewer';
                const pre = document.createElement('pre');
                pre.textContent = JSON.stringify(data, null, 2);
                dataView.appendChild(pre);
                entry.appendChild(dataView);
            }
            
            container.appendChild(entry);
            container.scrollTop = container.scrollHeight;
        }

        function clearLogs() {
            logs = [];
            document.getElementById('logContainer').innerHTML = 
                '<div class="log-entry log-info">ログをクリアしました</div>';
        }

        function exportLogs() {
            const logText = logs.map(log => 
                `[${log.timestamp}] [${log.type.toUpperCase()}] ${log.message}${log.data ? '\n' + JSON.stringify(log.data, null, 2) : ''}`
            ).join('\n\n');
            
            const blob = new Blob([logText], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `debug-${new Date().toISOString()}.log`;
            a.click();
        }

        // 接続状態を更新
        function updateConnectionStatus(status) {
            const indicator = document.getElementById('connectionStatus');
            indicator.className = `status-indicator status-${status}`;
        }

        // タブ切り替え
        function switchTab(tabName) {
            // 全てのタブコンテンツを非表示
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            // 全てのタブボタンを非アクティブ
            document.querySelectorAll('.tab-button').forEach(button => {
                button.classList.remove('active');
            });
            
            // 選択されたタブを表示
            document.getElementById(tabName).classList.add('active');
            
            // 対応するボタンをアクティブ
            event.target.classList.add('active');
        }

        // 強化されたAPI呼び出し関数
        async function makeRequest(method, endpoint, body = null, options = {}) {
            const baseUrl = document.getElementById('baseUrl').value;
            const authToken = document.getElementById('authToken').value;
            
            const url = `${baseUrl}${endpoint}`;
            const requestOptions = {
                method: method,
                headers: {
                    'Content-Type': 'application/json',
                },
                ...options
            };

            if (authToken) {
                requestOptions.headers['Authorization'] = authToken.startsWith('Bearer ') ? authToken : `Bearer ${authToken}`;
            }

            if (body && method !== 'GET') {
                requestOptions.body = JSON.stringify(body);
            }

            const startTime = performance.now();
            log(`🚀 ${method} ${url}`, 'info');
            
            try {
                const response = await fetch(url, requestOptions);
                const endTime = performance.now();
                const responseTime = Math.round(endTime - startTime);
                const responseText = await response.text();
                
                let responseData;
                try {
                    responseData = JSON.parse(responseText);
                } catch {
                    responseData = responseText;
                }

                // 接続履歴に記録
                recordConnectionHistory(endpoint, response.ok, responseTime, response.status);

                if (response.ok) {
                    log(`✅ ${response.status} - 成功 (${responseTime}ms)`, 'success', responseData);
                    updateConnectionStatus('connected');
                } else {
                    log(`❌ ${response.status} ${response.statusText} - 失敗 (${responseTime}ms)`, 'error', responseData);
                    updateConnectionStatus('disconnected');
                }

                return { response, data: responseData, responseTime };
            } catch (error) {
                const endTime = performance.now();
                const responseTime = Math.round(endTime - startTime);
                
                // 接続履歴にエラーを記録
                recordConnectionHistory(endpoint, false, responseTime, 0, error.message);
                
                log(`💥 ネットワークエラー: ${error.message} (${responseTime}ms)`, 'error');
                updateConnectionStatus('disconnected');
                return { error, responseTime };
            }
        }

        // 接続履歴記録関数
        function recordConnectionHistory(endpoint, success, responseTime, statusCode, errorMessage = null) {
            const record = {
                timestamp: new Date(),
                endpoint: endpoint,
                success: success,
                responseTime: responseTime,
                statusCode: statusCode,
                errorMessage: errorMessage
            };
            
            connectionMonitor.history.push(record);
            
            // 最新100件のみ保持
            if (connectionMonitor.history.length > 100) {
                connectionMonitor.history.shift();
            }
            
            // 統計更新
            updateConnectionStatistics();
            
            // グラフ更新
            updateConnectionChart();
        }

        // 接続統計更新
        function updateConnectionStatistics() {
            const history = connectionMonitor.history;
            if (history.length === 0) return;
            
            const recentHistory = history.slice(-20); // 直近20回
            const successCount = recentHistory.filter(r => r.success).length;
            const totalCount = recentHistory.length;
            const responseTimes = recentHistory.filter(r => r.success).map(r => r.responseTime);
            
            // 成功率
            const successRate = Math.round((successCount / totalCount) * 100);
            document.getElementById('successRateMetric').textContent = successRate;
            
            // 平均応答時間（レイテンシ）
            if (responseTimes.length > 0) {
                const avgResponseTime = Math.round(responseTimes.reduce((a, b) => a + b) / responseTimes.length);
                document.getElementById('latencyMetric').textContent = avgResponseTime;
                connectionMonitor.averageResponseTime = avgResponseTime;
            }
            
            // 安定性（応答時間のばらつき）
            if (responseTimes.length > 1) {
                const mean = responseTimes.reduce((a, b) => a + b) / responseTimes.length;
                const variance = responseTimes.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / responseTimes.length;
                const stability = Math.max(0, 100 - Math.sqrt(variance) / 10);
                document.getElementById('stabilityMetric').textContent = Math.round(stability);
            }
            
            // 品質評価
            let quality = '不明';
            if (successRate >= 95 && connectionMonitor.averageResponseTime < 500) {
                quality = '優秀';
            } else if (successRate >= 90 && connectionMonitor.averageResponseTime < 1000) {
                quality = '良好';
            } else if (successRate >= 80) {
                quality = '普通';
            } else {
                quality = '要改善';
            }
            document.getElementById('qualityMetric').textContent = quality;
        }

        // 接続チャート更新
        function updateConnectionChart() {
            const chart = document.getElementById('connectionChart');
            const history = connectionMonitor.history.slice(-50); // 直近50回
            
            if (history.length === 0) return;
            
            chart.innerHTML = '';
            
            history.forEach((record, index) => {
                const bar = document.createElement('div');
                bar.className = 'flex-1 min-w-0';
                
                const height = record.success ? 
                    Math.max(5, Math.min(100, (record.responseTime / 2000) * 100)) : 5;
                
                bar.innerHTML = `
                    <div class="w-full rounded-t ${record.success ? 'bg-green-500' : 'bg-red-500'}" 
                         style="height: ${height}%" 
                         title="${record.endpoint}: ${record.success ? record.responseTime + 'ms' : 'エラー'}">
                    </div>
                `;
                
                chart.appendChild(bar);
            });
        }

        // 強化された接続監視機能
        function toggleConnectionMonitor() {
            const button = document.getElementById('monitorToggle');
            
            if (!connectionMonitor.isActive) {
                startConnectionMonitor();
                button.textContent = '監視停止';
                button.className = button.className.replace('bg-blue-500', 'bg-red-500').replace('hover:bg-blue-600', 'hover:bg-red-600');
            } else {
                stopConnectionMonitor();
                button.textContent = '監視開始';
                button.className = button.className.replace('bg-red-500', 'bg-blue-500').replace('hover:bg-red-600', 'hover:bg-blue-600');
            }
        }

        function startConnectionMonitor() {
            connectionMonitor.isActive = true;
            connectionMonitor.interval = setInterval(checkAllEndpoints, 5000); // 5秒間隔
            log('📡 接続監視を開始しました', 'info');
            checkAllEndpoints(); // 即座に実行
        }

        function stopConnectionMonitor() {
            connectionMonitor.isActive = false;
            if (connectionMonitor.interval) {
                clearInterval(connectionMonitor.interval);
            }
            log('📡 接続監視を停止しました', 'info');
        }

        async function checkAllEndpoints() {
            for (const endpoint of connectionMonitor.endpoints) {
                await checkEndpoint(endpoint);
                await new Promise(resolve => setTimeout(resolve, 200)); // 200ms間隔
            }
            updateEndpointDetails();
        }

        async function checkEndpoint(endpoint) {
            try {
                const result = await makeRequest(endpoint.method, endpoint.url, null, { timeout: 5000 });
                
                const indicatorId = getIndicatorId(endpoint.name);
                const statusId = getStatusId(endpoint.name);
                const responseTimeId = getResponseTimeId(endpoint.name);
                
                if (result.data || result.response?.ok) {
                    updateEndpointUI(indicatorId, statusId, responseTimeId, true, result.responseTime);
                    connectionMonitor.successCount++;
                } else {
                    updateEndpointUI(indicatorId, statusId, responseTimeId, false, result.responseTime);
                    connectionMonitor.failureCount++;
                    
                    if (endpoint.critical) {
                        await attemptAutoReconnect(endpoint);
                    }
                }
            } catch (error) {
                const indicatorId = getIndicatorId(endpoint.name);
                const statusId = getStatusId(endpoint.name);
                const responseTimeId = getResponseTimeId(endpoint.name);
                
                updateEndpointUI(indicatorId, statusId, responseTimeId, false, 0, error.message);
                connectionMonitor.failureCount++;
            }
        }

        function getIndicatorId(endpointName) {
            const mapping = {
                'Health Check': 'apiStatusIndicator',
                'Applications API': 'dbStatusIndicator',
                'Auth API': 'authStatusIndicator',
                'Static Files': 'unifiedStatusIndicator'
            };
            return mapping[endpointName] || 'apiStatusIndicator';
        }

        function getStatusId(endpointName) {
            const mapping = {
                'Health Check': 'apiStatus',
                'Applications API': 'dbStatus',
                'Auth API': 'authStatus',
                'Static Files': 'unifiedStatus'
            };
            return mapping[endpointName] || 'apiStatus';
        }

        function getResponseTimeId(endpointName) {
            const mapping = {
                'Health Check': 'apiResponseTime',
                'Applications API': 'dbResponseTime',
                'Auth API': 'authResponseTime',
                'Static Files': 'unifiedResponseTime'
            };
            return mapping[endpointName] || 'apiResponseTime';
        }

        function updateEndpointUI(indicatorId, statusId, responseTimeId, success, responseTime, errorMessage = null) {
            const indicator = document.getElementById(indicatorId);
            const status = document.getElementById(statusId);
            const responseTimeElement = document.getElementById(responseTimeId);
            
            if (success) {
                indicator.className = 'status-indicator status-connected mr-2';
                status.textContent = '正常動作中';
                responseTimeElement.textContent = `応答: ${responseTime}ms`;
            } else {
                indicator.className = 'status-indicator status-disconnected mr-2';
                status.textContent = errorMessage || '接続失敗';
                responseTimeElement.textContent = `エラー`;
            }
        }

        async function attemptAutoReconnect(endpoint) {
            log(`🔄 ${endpoint.name} の自動復旧を試行中...`, 'warning');
            
            const config = connectionMonitor.retryConfig;
            let delay = config.retryDelay;
            
            for (let attempt = 1; attempt <= config.maxRetries; attempt++) {
                await new Promise(resolve => setTimeout(resolve, delay));
                
                try {
                    const result = await makeRequest(endpoint.method, endpoint.url);
                    if (result.data || result.response?.ok) {
                        log(`✅ ${endpoint.name} の自動復旧に成功 (試行${attempt}回目)`, 'success');
                        return true;
                    }
                } catch (error) {
                    log(`❌ ${endpoint.name} の復旧試行${attempt}回目失敗: ${error.message}`, 'error');
                }
                
                delay *= config.backoffMultiplier;
            }
            
            log(`💥 ${endpoint.name} の自動復旧に失敗しました`, 'error');
            return false;
        }

        async function runConnectionDiagnostics() {
            log('🔍 詳細接続診断を開始します', 'info');
            
            const diagnostics = {
                dns: await testDNSResolution(),
                ssl: await testSSLConnection(),
                firewall: await testFirewallBlocking(),
                cors: await testCORSPolicy(),
                bandwidth: await testBandwidth()
            };
            
            log('📊 詳細診断結果', 'info', diagnostics);
            updateConnectionIssues(diagnostics);
        }

        async function testDNSResolution() {
            try {
                const start = performance.now();
                await fetch('/health', { method: 'HEAD' });
                const end = performance.now();
                return { success: true, responseTime: Math.round(end - start) };
            } catch (error) {
                return { success: false, error: error.message };
            }
        }

        async function testSSLConnection() {
            try {
                const response = await fetch('https://nennkinn-claud.vercel.app/health');
                return { success: response.ok, protocol: 'HTTPS' };
            } catch (error) {
                return { success: false, error: error.message };
            }
        }

        async function testFirewallBlocking() {
            const endpoints = ['/health', '/applications', '/auth/login'];
            const results = [];
            
            for (const endpoint of endpoints) {
                try {
                    const response = await fetch(document.getElementById('baseUrl').value + endpoint, { method: 'HEAD' });
                    results.push({ endpoint, blocked: false, status: response.status });
                } catch (error) {
                    results.push({ endpoint, blocked: true, error: error.message });
                }
            }
            
            return results;
        }

        async function testCORSPolicy() {
            try {
                const response = await fetch(document.getElementById('baseUrl').value + '/health');
                const corsHeaders = {
                    'access-control-allow-origin': response.headers.get('access-control-allow-origin'),
                    'access-control-allow-methods': response.headers.get('access-control-allow-methods'),
                    'access-control-allow-headers': response.headers.get('access-control-allow-headers')
                };
                return { success: true, headers: corsHeaders };
            } catch (error) {
                return { success: false, error: error.message };
            }
        }

        async function testBandwidth() {
            const testSize = 1024; // 1KB のテストデータ
            const iterations = 5;
            const results = [];
            
            for (let i = 0; i < iterations; i++) {
                const start = performance.now();
                try {
                    await fetch('/health');
                    const end = performance.now();
                    results.push(end - start);
                } catch (error) {
                    results.push(null);
                }
            }
            
            const validResults = results.filter(r => r !== null);
            if (validResults.length > 0) {
                const avgTime = validResults.reduce((a, b) => a + b) / validResults.length;
                const estimatedBandwidth = (testSize / avgTime) * 1000; // KB/s
                return { success: true, bandwidth: Math.round(estimatedBandwidth), avgTime: Math.round(avgTime) };
            } else {
                return { success: false, error: 'すべてのテストが失敗' };
            }
        }

        function updateConnectionIssues(diagnostics) {
            const issuesContainer = document.getElementById('connectionIssues');
            issuesContainer.innerHTML = '';
            
            const issues = [];
            
            if (!diagnostics.dns.success) {
                issues.push({ type: 'DNS解決', severity: 'high', message: 'DNS解決に失敗しました' });
            }
            
            if (!diagnostics.ssl.success) {
                issues.push({ type: 'SSL接続', severity: 'high', message: 'HTTPS接続に問題があります' });
            }
            
            const blockedEndpoints = diagnostics.firewall.filter(r => r.blocked);
            if (blockedEndpoints.length > 0) {
                issues.push({ 
                    type: 'ファイアウォール', 
                    severity: 'medium', 
                    message: `${blockedEndpoints.length}個のエンドポイントがブロックされています` 
                });
            }
            
            if (!diagnostics.cors.success) {
                issues.push({ type: 'CORS', severity: 'medium', message: 'CORS設定に問題があります' });
            }
            
            if (diagnostics.bandwidth.success && diagnostics.bandwidth.bandwidth < 100) {
                issues.push({ type: '帯域幅', severity: 'low', message: '接続速度が低下しています' });
            }
            
            if (issues.length === 0) {
                issuesContainer.innerHTML = '<div class="text-green-600 text-sm">✅ 接続に問題は検出されませんでした</div>';
            } else {
                issues.forEach(issue => {
                    const div = document.createElement('div');
                    div.className = `p-3 rounded border-l-4 mb-2 ${
                        issue.severity === 'high' ? 'bg-red-50 border-red-500' :
                        issue.severity === 'medium' ? 'bg-yellow-50 border-yellow-500' :
                        'bg-blue-50 border-blue-500'
                    }`;
                    div.innerHTML = `
                        <div class="font-medium text-sm">${issue.type}</div>
                        <div class="text-sm text-gray-600">${issue.message}</div>
                    `;
                    issuesContainer.appendChild(div);
                });
            }
        }

        async function runSpeedTest() {
            log('⚡ 接続速度テストを開始します', 'info');
            
            const testSizes = [1, 10, 100]; // KB
            const results = [];
            
            for (const size of testSizes) {
                const times = [];
                for (let i = 0; i < 3; i++) {
                    const start = performance.now();
                    try {
                        await fetch('/health');
                        const end = performance.now();
                        times.push(end - start);
                    } catch (error) {
                        times.push(null);
                    }
                }
                
                const validTimes = times.filter(t => t !== null);
                if (validTimes.length > 0) {
                    const avgTime = validTimes.reduce((a, b) => a + b) / validTimes.length;
                    results.push({ size, avgTime: Math.round(avgTime) });
                }
            }
            
            log('⚡ 速度テスト完了', 'success', results);
        }

        function updateEndpointDetails() {
            const container = document.getElementById('endpointDetails');
            container.innerHTML = '';
            
            connectionMonitor.endpoints.forEach(endpoint => {
                const recentResults = connectionMonitor.history
                    .filter(h => h.endpoint === endpoint.url)
                    .slice(-10);
                
                const successCount = recentResults.filter(r => r.success).length;
                const successRate = recentResults.length > 0 ? Math.round((successCount / recentResults.length) * 100) : 0;
                const avgResponseTime = recentResults.length > 0 ? 
                    Math.round(recentResults.filter(r => r.success).reduce((sum, r) => sum + r.responseTime, 0) / Math.max(1, successCount)) : 0;
                
                const div = document.createElement('div');
                div.className = 'bg-white border rounded p-4';
                div.innerHTML = `
                    <div class="flex justify-between items-center mb-2">
                        <h4 class="font-medium">${endpoint.name}</h4>
                        <span class="text-sm ${endpoint.critical ? 'text-red-600' : 'text-gray-500'}">
                            ${endpoint.critical ? '重要' : '通常'}
                        </span>
                    </div>
                    <div class="grid grid-cols-3 gap-4 text-sm">
                        <div>
                            <span class="text-gray-600">成功率:</span>
                            <span class="font-medium">${successRate}%</span>
                        </div>
                        <div>
                            <span class="text-gray-600">平均応答:</span>
                            <span class="font-medium">${avgResponseTime}ms</span>
                        </div>
                        <div>
                            <span class="text-gray-600">直近結果:</span>
                            <span class="font-medium">${recentResults.length}件</span>
                        </div>
                    </div>
                    <div class="text-xs text-gray-500 mt-2">${endpoint.method} ${endpoint.url}</div>
                `;
                
                container.appendChild(div);
            });
        }

        // 基本テスト関数（強化版）
        async function testHealthCheck() {
            log('🏥 ヘルスチェックを実行中...', 'info');
            updateConnectionStatus('checking');
            
            const result = await makeRequest('GET', '/health');
            if (result.data) {
                document.getElementById('apiStatus').textContent = '正常動作中';
                document.getElementById('apiResponseTime').textContent = `応答: ${result.responseTime}ms`;
            } else {
                document.getElementById('apiStatus').textContent = '接続失敗';
                document.getElementById('apiResponseTime').textContent = 'エラー';
            }
        }

        // 負荷テスト機能
        async function runLoadTest() {
            log('🚀 負荷テストを開始します', 'info');
            
            const concurrency = 5; // 同時接続数
            const totalRequests = 20; // 総リクエスト数
            const endpoint = '/health';
            
            const results = [];
            const startTime = performance.now();
            
            // 同時リクエストの実行
            const promises = [];
            for (let i = 0; i < concurrency; i++) {
                promises.push(runConcurrentRequests(endpoint, totalRequests / concurrency, results));
            }
            
            await Promise.all(promises);
            
            const endTime = performance.now();
            const totalTime = endTime - startTime;
            
            // 結果分析
            const successfulRequests = results.filter(r => r.success).length;
            const failedRequests = results.length - successfulRequests;
            const averageResponseTime = successfulRequests > 0 ? 
                results.filter(r => r.success).reduce((sum, r) => sum + r.responseTime, 0) / successfulRequests : 0;
            
            const loadTestResults = {
                totalRequests: results.length,
                successful: successfulRequests,
                failed: failedRequests,
                successRate: Math.round((successfulRequests / results.length) * 100),
                averageResponseTime: Math.round(averageResponseTime),
                totalTime: Math.round(totalTime),
                requestsPerSecond: Math.round(results.length / (totalTime / 1000))
            };
            
            log('🚀 負荷テスト完了', 'success', loadTestResults);
        }

        async function runConcurrentRequests(endpoint, count, results) {
            for (let i = 0; i < count; i++) {
                try {
                    const result = await makeRequest('GET', endpoint);
                    results.push({
                        success: result.response?.ok || false,
                        responseTime: result.responseTime || 0,
                        timestamp: new Date()
                    });
                } catch (error) {
                    results.push({
                        success: false,
                        responseTime: 0,
                        error: error.message,
                        timestamp: new Date()
                    });
                }
                
                // 小さな遅延を追加してサーバーの負荷を軽減
                await new Promise(resolve => setTimeout(resolve, 100));
            }
        }

        // 障害復旧テスト
        async function runFailoverTest() {
            log('🔄 障害復旧テストを開始します', 'info');
            
            const endpoints = connectionMonitor.endpoints.filter(e => e.critical);
            const failoverResults = [];
            
            for (const endpoint of endpoints) {
                log(`🔄 ${endpoint.name} の障害復旧テスト実行中...`, 'info');
                
                // 故意に失敗させるテスト（無効なエンドポイント）
                const invalidEndpoint = endpoint.url + '-invalid';
                const failureResult = await makeRequest(endpoint.method, invalidEndpoint);
                
                if (!failureResult.response?.ok) {
                    log(`✅ ${endpoint.name} の障害検出に成功`, 'success');
                    
                    // 自動復旧テスト
                    const recoveryResult = await attemptAutoReconnect(endpoint);
                    
                    failoverResults.push({
                        endpoint: endpoint.name,
                        failureDetected: true,
                        recoverySuccessful: recoveryResult,
                        recoveryTime: Date.now() // 簡易的な時間記録
                    });
                } else {
                    failoverResults.push({
                        endpoint: endpoint.name,
                        failureDetected: false,
                        recoverySuccessful: false
                    });
                }
            }
            
            log('🔄 障害復旧テスト完了', 'success', failoverResults);
        }

        // 連続監視機能
        async function startContinuousMonitoring() {
            const button = document.getElementById('continuousMonitorBtn');
            
            if (!connectionMonitor.isActive) {
                connectionMonitor.isActive = true;
                connectionMonitor.interval = setInterval(async () => {
                    await checkAllEndpoints();
                    
                    // 問題検出時の自動対応
                    const recentFailures = connectionMonitor.history
                        .slice(-5)
                        .filter(h => !h.success).length;
                    
                    if (recentFailures >= 3) {
                        log('⚠️ 連続的な接続問題を検出、詳細診断を実行中...', 'warning');
                        await runConnectionDiagnostics();
                    }
                }, 3000); // 3秒間隔
                
                button.textContent = '📡 監視停止';
                button.className = button.className.replace('bg-blue-500', 'bg-red-500').replace('hover:bg-blue-600', 'hover:bg-red-600');
                
                log('📡 連続監視を開始しました (3秒間隔)', 'info');
            } else {
                stopConnectionMonitor();
                button.textContent = '📡 連続監視開始';
                button.className = button.className.replace('bg-red-500', 'bg-blue-500').replace('hover:bg-red-600', 'hover:bg-blue-600');
            }
        }

        async function testLogin() {
            log('🔐 ログインテストを実行中...', 'info');
            const credentials = {
                email: 'admin@disability-pension.jp',
                password: 'admin123'
            };
            const result = await makeRequest('POST', '/auth/login', credentials);
            
            if (result.data && result.data.token) {
                document.getElementById('authToken').value = result.data.token;
                document.getElementById('authStatus').textContent = 'ログイン可能';
                document.getElementById('authResponseTime').textContent = `応答: ${result.responseTime}ms`;
                log('🎉 トークンを自動設定しました', 'success');
            } else {
                document.getElementById('authStatus').textContent = '認証エラー';
                document.getElementById('authResponseTime').textContent = 'エラー';
            }
        }

        async function testApplications() {
            log('📋 申請データ取得テストを実行中...', 'info');
            const result = await makeRequest('GET', '/applications?limit=3');
            
            if (result.data && result.data.applications) {
                document.getElementById('dbStatus').textContent = `接続済み (${result.data.applications.length}件)`;
            } else {
                document.getElementById('dbStatus').textContent = '接続エラー';
            }
        }

        async function testDatabaseConnection() {
            log('🗄️ データベース接続をテスト中...', 'info');
            
            try {
                // ApplicationAPIが利用可能か確認
                if (typeof ApplicationAPI !== 'undefined') {
                    const result = await ApplicationAPI.getApplications({ limit: 1 });
                    log('✅ データベース接続成功', 'success', result);
                    document.getElementById('dbStatus').textContent = '接続済み';
                } else {
                    // API経由でテスト
                    await testApplications();
                }
            } catch (error) {
                log(`❌ データベース接続エラー: ${error.message}`, 'error', error);
                document.getElementById('dbStatus').textContent = '接続エラー';
            }
        }

        async function sendCustomRequest() {
            const method = document.getElementById('method').value;
            const endpoint = document.getElementById('endpoint').value;
            const bodyText = document.getElementById('requestBody').value;

            let body = null;
            if (bodyText.trim()) {
                try {
                    body = JSON.parse(bodyText);
                } catch (error) {
                    log(`❌ JSONパースエラー: ${error.message}`, 'error');
                    return;
                }
            }

            await makeRequest(method, endpoint, body);
        }

        // project-unified 診断関数
        async function testUnifiedPageLoad() {
            log('🔍 project-unified.html ページ読み込みテスト開始', 'info');
            
            try {
                const response = await fetch('/project-unified.html');
                if (response.ok) {
                    const html = await response.text();
                    log('✅ project-unified.html 読み込み成功', 'success');
                    
                    // JavaScript依存関係をチェック
                    if (html.includes('js/application-api.js')) {
                        log('📍 application-api.js の依存関係を確認', 'info');
                        await testApplicationApiLoad();
                    }
                    
                    document.getElementById('unifiedStatus').textContent = 'ページ読み込み成功';
                } else {
                    log(`❌ project-unified.html 読み込み失敗: ${response.status}`, 'error');
                    document.getElementById('unifiedStatus').textContent = '読み込み失敗';
                }
            } catch (error) {
                log(`💥 ページ読み込みエラー: ${error.message}`, 'error');
                document.getElementById('unifiedStatus').textContent = '接続エラー';
            }
        }

        async function testApplicationApiLoad() {
            log('🔧 application-api.js ロードテスト開始', 'info');
            
            try {
                const response = await fetch('/js/application-api.js');
                if (response.ok) {
                    const jsCode = await response.text();
                    log('✅ application-api.js ファイル存在確認', 'success');
                    
                    // APIベースURL設定をチェック
                    if (jsCode.includes('getAPIBaseURL')) {
                        log('📍 API設定関数を確認', 'debug');
                    }
                    
                    // ApplicationAPIオブジェクトの存在確認
                    if (typeof ApplicationAPI !== 'undefined') {
                        log('✅ ApplicationAPI オブジェクトが利用可能', 'success');
                    } else {
                        log('⚠️ ApplicationAPI オブジェクトが未読み込み', 'warning');
                    }
                } else {
                    log(`❌ application-api.js 読み込み失敗: ${response.status}`, 'error');
                }
            } catch (error) {
                log(`💥 application-api.js 読み込みエラー: ${error.message}`, 'error');
            }
        }

        async function simulateEditMode() {
            log('🎭 編集モード(?edit=1) 模擬テスト開始', 'info');
            const applicationId = document.getElementById('testApplicationId').value || '1';
            
            try {
                // 申請データの取得テスト
                log(`📊 申請データ読み込みテスト (ID: ${applicationId})`, 'info');
                const result = await makeRequest('GET', `/applications/${applicationId}`);
                
                if (result.data) {
                    log('✅ 申請データ取得成功', 'success', result.data);
                    document.getElementById('unifiedStatus').textContent = '編集モード対応';
                    
                    // ローカルストレージへの保存をシミュレート
                    localStorage.setItem(`application_${applicationId}`, JSON.stringify(result.data));
                    log('💾 ローカルストレージに保存しました', 'info');
                } else {
                    log('❌ 申請データが見つかりません', 'error');
                    document.getElementById('unifiedStatus').textContent = 'データ不明';
                }
            } catch (error) {
                log(`💥 編集モード模擬エラー: ${error.message}`, 'error');
                document.getElementById('unifiedStatus').textContent = 'エラー';
            }
        }

        async function testLocalStorageData() {
            log('🗄️ ローカルストレージデータ確認', 'info');
            
            const applicationId = document.getElementById('testApplicationId').value || '1';
            const storageKey = `application_${applicationId}`;
            const storedData = localStorage.getItem(storageKey);
            
            if (storedData) {
                try {
                    const parsedData = JSON.parse(storedData);
                    log(`✅ ローカルストレージデータ発見 (${storageKey})`, 'success', parsedData);
                } catch (error) {
                    log(`❌ ローカルストレージデータのパースエラー: ${error.message}`, 'error');
                }
            } else {
                log(`⚠️ ローカルストレージにデータが存在しません (${storageKey})`, 'warning');
                
                // 全てのキーを調査
                const allKeys = Object.keys(localStorage);
                if (allKeys.length > 0) {
                    log(`📋 存在するローカルストレージキー:`, 'info', allKeys);
                } else {
                    log('📋 ローカルストレージは空です', 'info');
                }
            }
        }

        // 強化されたproject-unified診断関数
        async function testProjectUnifiedDirectly() {
            log('🎯 project-unified.html 直接テスト開始', 'info');
            
            try {
                // iframe内でproject-unified.htmlを読み込みテスト
                const iframe = document.createElement('iframe');
                iframe.style.display = 'none';
                iframe.src = '/project-unified.html?edit=1';
                
                document.body.appendChild(iframe);
                
                const loadPromise = new Promise((resolve, reject) => {
                    iframe.onload = () => resolve(iframe);
                    iframe.onerror = () => reject(new Error('iframe読み込み失敗'));
                    setTimeout(() => reject(new Error('読み込みタイムアウト')), 10000);
                });
                
                const loadedIframe = await loadPromise;
                log('✅ project-unified.html iframe読み込み成功', 'success');
                
                // JavaScript実行エラーをチェック
                setTimeout(() => {
                    try {
                        const iframeDoc = loadedIframe.contentDocument;
                        if (iframeDoc) {
                            const scripts = iframeDoc.querySelectorAll('script');
                            log(`📊 発見されたスクリプト: ${scripts.length}個`, 'info');
                            
                            // application-api.jsの存在確認
                            const apiScript = Array.from(scripts).find(s => s.src.includes('application-api.js'));
                            if (apiScript) {
                                log('✅ application-api.js スクリプトタグ確認', 'success');
                            } else {
                                log('⚠️ application-api.js スクリプトタグが見つかりません', 'warning');
                            }
                        }
                    } catch (error) {
                        log(`⚠️ iframe内容アクセス制限: ${error.message}`, 'warning');
                    }
                    
                    document.body.removeChild(loadedIframe);
                }, 2000);
                
            } catch (error) {
                log(`❌ project-unified直接テストエラー: ${error.message}`, 'error');
            }
        }

        async function simulateFormSubmission() {
            log('📝 フォーム送信模擬テスト開始', 'info');
            
            try {
                // 申請データの模擬生成
                const mockFormData = {
                    applicantName: 'テスト太郎',
                    applicantNameKana: 'テストタロウ',
                    birthDate: '1990-01-01',
                    gender: 'male',
                    phoneNumber: '090-1234-5678',
                    email: 'test@example.com',
                    address: '東京都新宿区テスト1-1-1',
                    disabilityType: 'mental',
                    disabilityGrade: 2,
                    status: 'draft'
                };
                
                log('📊 模擬フォームデータ生成', 'info', mockFormData);
                
                // POSTリクエストでの送信テスト
                const result = await makeRequest('POST', '/applications', mockFormData);
                
                if (result.data) {
                    log('✅ フォーム送信模擬成功', 'success', result.data);
                } else {
                    log('❌ フォーム送信模擬失敗', 'error');
                }
                
            } catch (error) {
                log(`💥 フォーム送信模擬エラー: ${error.message}`, 'error');
            }
        }

        async function testDOMManipulation() {
            log('🎨 DOM操作テスト開始', 'info');
            
            try {
                // テスト用のDOM要素を作成
                const testContainer = document.createElement('div');
                testContainer.id = 'test-container';
                testContainer.style.display = 'none';
                document.body.appendChild(testContainer);
                
                // project-unified.htmlの典型的なDOM構造を模擬
                testContainer.innerHTML = `
                    <form id="application-form">
                        <input type="text" id="applicantName" value="テスト太郎">
                        <input type="email" id="email" value="test@example.com">
                        <select id="disabilityType">
                            <option value="mental">精神障害</option>
                            <option value="physical">身体障害</option>
                        </select>
                    </form>
                    <div id="error-display"></div>
                    <div id="loading-indicator" style="display: none;">読み込み中...</div>
                `;
                
                // DOM操作のテスト
                const form = testContainer.querySelector('#application-form');
                const nameInput = testContainer.querySelector('#applicantName');
                const emailInput = testContainer.querySelector('#email');
                
                if (form && nameInput && emailInput) {
                    log('✅ DOM要素の作成と取得成功', 'success');
                    
                    // フォームデータの取得テスト
                    const formData = new FormData(form);
                    const formObject = Object.fromEntries(formData);
                    log('📊 フォームデータ取得テスト', 'info', formObject);
                    
                    // 動的な値の変更テスト
                    nameInput.value = '変更されたテスト太郎';
                    emailInput.value = 'changed@example.com';
                    
                    log('✅ DOM値変更テスト成功', 'success', {
                        name: nameInput.value,
                        email: emailInput.value
                    });
                } else {
                    log('❌ DOM要素の取得に失敗', 'error');
                }
                
                // クリーンアップ
                document.body.removeChild(testContainer);
                log('🧹 テスト用DOM要素をクリーンアップ', 'info');
                
            } catch (error) {
                log(`💥 DOM操作テストエラー: ${error.message}`, 'error');
            }
        }

        async function validateProjectUnifiedIntegrity() {
            log('🔍 project-unified.html 整合性検証開始', 'info');
            
            try {
                // ファイルの存在と内容の確認
                const response = await fetch('/project-unified.html');
                const html = await response.text();
                
                const validationResults = {
                    fileExists: response.ok,
                    hasApplicationApiScript: html.includes('js/application-api.js'),
                    hasDOMContentLoadedListener: html.includes('DOMContentLoaded'),
                    hasAPIBaseURLDefined: html.includes('API_BASE_URL'),
                    hasErrorHandling: html.includes('catch') || html.includes('error'),
                    hasFormElements: html.includes('<form') || html.includes('input'),
                    hasJavaScriptFunctions: html.includes('function ') || html.includes('async '),
                    fileSize: html.length
                };
                
                log('📊 整合性検証結果', 'info', validationResults);
                
                // 検証結果の評価
                const issues = [];
                if (!validationResults.hasApplicationApiScript) {
                    issues.push('application-api.js スクリプトが見つかりません');
                }
                if (!validationResults.hasDOMContentLoadedListener) {
                    issues.push('DOMContentLoadedイベントリスナーが見つかりません');
                }
                if (!validationResults.hasAPIBaseURLDefined) {
                    issues.push('API_BASE_URL定義が見つかりません');
                }
                if (!validationResults.hasErrorHandling) {
                    issues.push('エラーハンドリングが不十分です');
                }
                
                if (issues.length === 0) {
                    log('✅ project-unified.html 整合性検証成功', 'success');
                    document.getElementById('unifiedStatus').textContent = '整合性OK';
                } else {
                    log(`⚠️ 発見された問題点:`, 'warning', issues);
                    document.getElementById('unifiedStatus').textContent = `問題${issues.length}件`;
                }
                
            } catch (error) {
                log(`💥 整合性検証エラー: ${error.message}`, 'error');
                document.getElementById('unifiedStatus').textContent = '検証エラー';
            }
        }

        // 自動診断シーケンス
        async function runFullDiagnosis() {
            const button = document.getElementById('diagnosisButton');
            const progress = document.getElementById('diagnosisProgress');
            const status = document.getElementById('diagnosisStatus');
            const results = document.getElementById('diagnosisResults');
            
            button.disabled = true;
            button.textContent = '診断実行中...';
            results.innerHTML = '';
            
            const steps = [
                { name: 'システム接続確認', func: testHealthCheck, weight: 15 },
                { name: 'データベース接続', func: testDatabaseConnection, weight: 15 },
                { name: '認証システム確認', func: testLogin, weight: 10 },
                { name: 'project-unified読み込み', func: testUnifiedPageLoad, weight: 20 },
                { name: 'API依存関係確認', func: testApplicationApiLoad, weight: 15 },
                { name: 'ローカルストレージ', func: testLocalStorageData, weight: 10 },
                { name: '編集モード模擬', func: simulateEditMode, weight: 15 }
            ];
            
            let totalProgress = 0;
            
            for (let i = 0; i < steps.length; i++) {
                const step = steps[i];
                status.textContent = `${step.name}を実行中... (${i + 1}/${steps.length})`;
                
                const startTime = Date.now();
                try {
                    await step.func();
                    const duration = Date.now() - startTime;
                    addDiagnosisResult(step.name, '成功', duration, 'success');
                } catch (error) {
                    const duration = Date.now() - startTime;
                    addDiagnosisResult(step.name, `失敗: ${error.message}`, duration, 'error');
                }
                
                totalProgress += step.weight;
                progress.style.width = `${totalProgress}%`;
                
                // 少し待機してUIを更新
                await new Promise(resolve => setTimeout(resolve, 500));
            }
            
            status.textContent = '完全診断完了';
            button.disabled = false;
            button.textContent = '🚀 完全診断開始';
            
            log('🎉 完全診断シーケンス完了', 'success');
        }

        async function runQuickDiagnosis() {
            log('⚡ クイック診断開始', 'info');
            
            const quickSteps = [
                testHealthCheck,
                testApplicationApiLoad,
                simulateEditMode
            ];
            
            for (const step of quickSteps) {
                try {
                    await step();
                } catch (error) {
                    log(`クイック診断ステップでエラー: ${error.message}`, 'error');
                }
            }
            
            log('⚡ クイック診断完了', 'success');
        }

        function addDiagnosisResult(stepName, result, duration, type) {
            const results = document.getElementById('diagnosisResults');
            const div = document.createElement('div');
            div.className = `p-3 rounded border-l-4 ${
                type === 'success' ? 'bg-green-50 border-green-500' : 'bg-red-50 border-red-500'
            }`;
            
            div.innerHTML = `
                <div class="flex justify-between items-center">
                    <span class="font-medium">${stepName}</span>
                    <span class="text-sm text-gray-500">${duration}ms</span>
                </div>
                <div class="text-sm ${type === 'success' ? 'text-green-700' : 'text-red-700'}">${result}</div>
            `;
            
            results.appendChild(div);
        }

        // パフォーマンス監視機能
        async function measurePageLoadTime() {
            log('📊 ページ読み込み速度測定開始', 'info');
            
            const startTime = performance.now();
            
            try {
                const response = await fetch('/project-unified.html');
                const html = await response.text();
                const endTime = performance.now();
                const loadTime = Math.round(endTime - startTime);
                
                document.getElementById('loadTimeMetric').textContent = loadTime;
                appendPerformanceLog(`ページ読み込み: ${loadTime}ms`);
                
                log(`📊 ページ読み込み完了: ${loadTime}ms`, 'success');
            } catch (error) {
                log(`💥 ページ読み込み測定エラー: ${error.message}`, 'error');
            }
        }

        async function measureAPIResponseTime() {
            log('🌐 API応答時間測定開始', 'info');
            
            const endpoints = ['/health', '/applications?limit=1'];
            const responseTimes = [];
            
            for (const endpoint of endpoints) {
                const startTime = performance.now();
                try {
                    await makeRequest('GET', endpoint);
                    const endTime = performance.now();
                    const responseTime = Math.round(endTime - startTime);
                    responseTimes.push(responseTime);
                    appendPerformanceLog(`${endpoint}: ${responseTime}ms`);
                } catch (error) {
                    appendPerformanceLog(`${endpoint}: エラー`);
                }
            }
            
            if (responseTimes.length > 0) {
                const averageTime = Math.round(responseTimes.reduce((a, b) => a + b) / responseTimes.length);
                document.getElementById('apiResponseMetric').textContent = averageTime;
                log(`🌐 API平均応答時間: ${averageTime}ms`, 'success');
            }
        }

        async function analyzeMemoryUsage() {
            log('💾 メモリ使用量分析開始', 'info');
            
            if (performance.memory) {
                const memory = performance.memory;
                const usedMB = Math.round(memory.usedJSHeapSize / 1024 / 1024);
                const totalMB = Math.round(memory.totalJSHeapSize / 1024 / 1024);
                const limitMB = Math.round(memory.jsHeapSizeLimit / 1024 / 1024);
                
                document.getElementById('memoryUsageMetric').textContent = usedMB;
                
                appendPerformanceLog(`使用中: ${usedMB}MB / 合計: ${totalMB}MB / 上限: ${limitMB}MB`);
                
                log(`💾 メモリ使用量: ${usedMB}MB`, 'success', {
                    used: usedMB,
                    total: totalMB,
                    limit: limitMB
                });
            } else {
                log('⚠️ メモリ情報が利用できません', 'warning');
                appendPerformanceLog('メモリ情報が利用できません');
            }
        }

        function appendPerformanceLog(message) {
            const log = document.getElementById('performanceLog');
            const timestamp = new Date().toLocaleTimeString('ja-JP');
            const div = document.createElement('div');
            div.textContent = `[${timestamp}] ${message}`;
            log.appendChild(div);
            log.scrollTop = log.scrollHeight;
        }

        // コンソール監視機能
        function toggleConsoleCapture() {
            const button = document.getElementById('consoleToggle');
            const output = document.getElementById('consoleOutput');
            
            if (!consoleCapturing) {
                // コンソール監視開始
                originalConsole.log = console.log;
                originalConsole.error = console.error;
                originalConsole.warn = console.warn;
                originalConsole.info = console.info;
                
                console.log = function(...args) {
                    originalConsole.log.apply(console, args);
                    appendConsoleLog('LOG', args.join(' '), '#4ade80');
                };
                
                console.error = function(...args) {
                    originalConsole.error.apply(console, args);
                    appendConsoleLog('ERROR', args.join(' '), '#ef4444');
                };
                
                console.warn = function(...args) {
                    originalConsole.warn.apply(console, args);
                    appendConsoleLog('WARN', args.join(' '), '#f59e0b');
                };
                
                console.info = function(...args) {
                    originalConsole.info.apply(console, args);
                    appendConsoleLog('INFO', args.join(' '), '#3b82f6');
                };
                
                consoleCapturing = true;
                button.textContent = 'コンソール監視停止';
                button.className = button.className.replace('bg-green-500', 'bg-red-500').replace('hover:bg-green-600', 'hover:bg-red-600');
                output.innerHTML = '<div style="color: #4ade80;">コンソール監視開始...</div>';
                
                log('📊 コンソール監視を開始しました', 'info');
            } else {
                // コンソール監視停止
                console.log = originalConsole.log;
                console.error = originalConsole.error;
                console.warn = originalConsole.warn;
                console.info = originalConsole.info;
                
                consoleCapturing = false;
                button.textContent = 'コンソール監視開始';
                button.className = button.className.replace('bg-red-500', 'bg-green-500').replace('hover:bg-red-600', 'hover:bg-green-600');
                
                log('📊 コンソール監視を停止しました', 'info');
            }
        }
        
        function appendConsoleLog(level, message, color) {
            const output = document.getElementById('consoleOutput');
            const timestamp = new Date().toLocaleTimeString('ja-JP');
            const div = document.createElement('div');
            div.style.color = color;
            div.textContent = `[${timestamp}] [${level}] ${message}`;
            output.appendChild(div);
            output.scrollTop = output.scrollHeight;
        }
        
        function clearConsoleLog() {
            document.getElementById('consoleOutput').innerHTML = 'コンソール監視待機中...';
        }

        // ネットワーク監視機能
        function toggleNetworkCapture() {
            const button = document.getElementById('networkToggle');
            const output = document.getElementById('networkOutput');
            
            if (!networkCapturing) {
                // ネットワーク監視開始
                originalFetch = window.fetch;
                
                window.fetch = async function(...args) {
                    const startTime = Date.now();
                    const url = args[0];
                    const options = args[1] || {};
                    
                    appendNetworkLog(`🚀 ${options.method || 'GET'} ${url}`, '#3b82f6');
                    
                    try {
                        const response = await originalFetch.apply(this, args);
                        const duration = Date.now() - startTime;
                        const status = response.status;
                        const color = status >= 200 && status < 300 ? '#4ade80' : '#ef4444';
                        
                        appendNetworkLog(`${status >= 200 && status < 300 ? '✅' : '❌'} ${status} ${url} (${duration}ms)`, color);
                        
                        return response;
                    } catch (error) {
                        const duration = Date.now() - startTime;
                        appendNetworkLog(`💥 ERROR ${url} (${duration}ms): ${error.message}`, '#ef4444');
                        throw error;
                    }
                };
                
                networkCapturing = true;
                button.textContent = 'ネットワーク監視停止';
                button.className = button.className.replace('bg-blue-500', 'bg-red-500').replace('hover:bg-blue-600', 'hover:bg-red-600');
                output.innerHTML = '<div class="text-blue-500 text-sm">ネットワーク監視開始...</div>';
                
                log('🌐 ネットワーク監視を開始しました', 'info');
            } else {
                // ネットワーク監視停止
                if (originalFetch) {
                    window.fetch = originalFetch;
                }
                
                networkCapturing = false;
                button.textContent = 'ネットワーク監視開始';
                button.className = button.className.replace('bg-red-500', 'bg-blue-500').replace('hover:bg-red-600', 'hover:bg-blue-600');
                
                log('🌐 ネットワーク監視を停止しました', 'info');
            }
        }
        
        function appendNetworkLog(message, color) {
            const output = document.getElementById('networkOutput');
            const timestamp = new Date().toLocaleTimeString('ja-JP');
            const div = document.createElement('div');
            div.className = 'text-sm py-1';
            div.style.color = color;
            div.textContent = `[${timestamp}] ${message}`;
            output.appendChild(div);
            output.scrollTop = output.scrollHeight;
        }
        
        function clearNetworkLog() {
            document.getElementById('networkOutput').innerHTML = '<div class="text-gray-500 text-sm">ネットワーク監視待機中...</div>';
        }

        // 初期化
        document.addEventListener('DOMContentLoaded', async function() {
            log('🔧 統合デバッグツールを初期化中...', 'info');
            
            // 自動的にヘルスチェックを実行
            await testHealthCheck();
            
            // ApplicationAPIの状態を確認
            if (typeof ApplicationAPI !== 'undefined') {
                log('✅ ApplicationAPIが読み込まれました', 'success');
            } else {
                log('⚠️ ApplicationAPIが見つかりません', 'warning');
                log('💡 js/application-api.jsファイルが正しく読み込まれているか確認してください', 'info');
            }
            
            // エラーハンドリング
            window.addEventListener('error', function(event) {
                log(`🐛 JavaScriptエラー: ${event.message}`, 'error', {
                    filename: event.filename,
                    line: event.lineno,
                    column: event.colno,
                    error: event.error?.stack
                });
            });
            
            // Enter キーでリクエスト送信
            document.getElementById('endpoint').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    sendCustomRequest();
                }
            });
            
            log('✅ 統合デバッグツールの初期化完了', 'success');
        });
    </script>
</body>
</html>